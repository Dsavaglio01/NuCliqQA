{"version":3,"sources":["ImageCropOverlay.tsx"],"names":["horizontalSections","verticalSections","ImageCropOverlay","selectedFrameSection","setSelectedFrameSection","React","useState","cropSize","setCropSize","cropSizeState","imageBounds","imageBoundsState","accumulatedPan","setAccumluatedPan","accumulatedPanState","fixedAspectRatio","lockAspectRatio","minimumCropDimensions","EditorContext","animatedCropSize","width","Animated","Value","height","panX","useRef","x","panY","y","useEffect","checkCropBounds","translationX","translationY","setValue","newSize","imageAspectRatio","isMovingSection","isLeft","endsWith","isTop","startsWith","onOverlayMove","nativeEvent","event","current","useNativeDriver","getTargetCropFrameBounds","initialWidth","initialHeight","position","onOverlayRelease","checkResizeBounds","onHandlerStateChange","state","State","END","accDx","limitedXPos","accDy","limitedYPos","maxWidth","maxHeight","minWidth","minHeight","animatedWidth","animatedHeight","finalHeight","finalWidth","styles","container","e","overlay","transform","translateX","add","translateY","map","hsection","sectionRow","vsection","key","defaultSection","cornerMarker","top","borderTopWidth","bottom","borderBottomWidth","left","borderLeftWidth","right","borderRightWidth","StyleSheet","create","backgroundColor","borderColor","borderWidth","flexDirection","flex","justifyContent","alignItems"],"mappings":";;;;;;;AAAA;;AACA;;AAUA;;AACA;;AACA;;AAOA;;;;;;AAEA,MAAMA,kBAAkB,GAAG,CAAC,KAAD,EAAQ,QAAR,EAAkB,QAAlB,CAA3B;AACA,MAAMC,gBAAgB,GAAG,CAAC,MAAD,EAAS,QAAT,EAAmB,OAAnB,CAAzB;;AAEA,MAAMC,gBAAgB,GAAG,MAAM;AAC7B;AACA;AACA,QAAM,CAACC,oBAAD,EAAuBC,uBAAvB,IAAkDC,KAAK,CAACC,QAAN,CAAe,EAAf,CAAxD,CAH6B,CAK7B;;AACA,QAAM,CAACC,QAAD,EAAWC,WAAX,IAA0B,4BAAeC,oBAAf,CAAhC;AACA,QAAM,CAACC,WAAD,IAAgB,4BAAeC,uBAAf,CAAtB;AACA,QAAM,CAACC,cAAD,EAAiBC,iBAAjB,IACJ,4BAAeC,0BAAf,CADF,CAR6B,CAU7B;;AACA,QAAM;AAAEC,IAAAA,gBAAF;AAAoBC,IAAAA,eAApB;AAAqCC,IAAAA;AAArC,MACJ,sBAAWC,oBAAX,CADF;AAGA,QAAM,CAACC,gBAAD,IAAqBd,KAAK,CAACC,QAAN,CAAe;AACxCc,IAAAA,KAAK,EAAE,IAAIC,sBAASC,KAAb,CAAmBf,QAAQ,CAACa,KAA5B,CADiC;AAExCG,IAAAA,MAAM,EAAE,IAAIF,sBAASC,KAAb,CAAmBf,QAAQ,CAACgB,MAA5B;AAFgC,GAAf,CAA3B,CAd6B,CAmB7B;AACA;AACA;;AACA,QAAMC,IAAI,GAAGnB,KAAK,CAACoB,MAAN,CAAa,IAAIJ,sBAASC,KAAb,CAAmBZ,WAAW,CAACgB,CAA/B,CAAb,CAAb;AACA,QAAMC,IAAI,GAAGtB,KAAK,CAACoB,MAAN,CAAa,IAAIJ,sBAASC,KAAb,CAAmBZ,WAAW,CAACkB,CAA/B,CAAb,CAAb;AAEAvB,EAAAA,KAAK,CAACwB,SAAN,CAAgB,MAAM;AACpB;AACA;AACAC,IAAAA,eAAe,CAAC;AACdC,MAAAA,YAAY,EAAE,CADA;AAEdC,MAAAA,YAAY,EAAE;AAFA,KAAD,CAAf,CAHoB,CAOpB;;AACAb,IAAAA,gBAAgB,CAACI,MAAjB,CAAwBU,QAAxB,CAAiC1B,QAAQ,CAACgB,MAA1C;AACAJ,IAAAA,gBAAgB,CAACC,KAAjB,CAAuBa,QAAvB,CAAgC1B,QAAQ,CAACa,KAAzC;AACD,GAVD,EAUG,CAACb,QAAD,CAVH;AAYAF,EAAAA,KAAK,CAACwB,SAAN,CAAgB,MAAM;AACpB;AACA,QAAIK,OAAO,GAAG;AAAEd,MAAAA,KAAK,EAAE,CAAT;AAAYG,MAAAA,MAAM,EAAE;AAApB,KAAd;AACA,UAAM;AAAEH,MAAAA,KAAF;AAASG,MAAAA;AAAT,QAAoBb,WAA1B;AACA,UAAMyB,gBAAgB,GAAGf,KAAK,GAAGG,MAAjC,CAJoB,CAKpB;;AACA,QAAIR,gBAAgB,GAAGoB,gBAAvB,EAAyC;AACvC;AACAD,MAAAA,OAAO,CAACX,MAAR,GAAiBA,MAAjB;AACAW,MAAAA,OAAO,CAACd,KAAR,GAAgBG,MAAM,GAAGR,gBAAzB;AACD,KAJD,MAIO;AACL;AACAmB,MAAAA,OAAO,CAACd,KAAR,GAAgBA,KAAhB;AACAc,MAAAA,OAAO,CAACX,MAAR,GAAiBH,KAAK,GAAGL,gBAAzB;AACD,KAdmB,CAepB;;;AACAP,IAAAA,WAAW,CAAC0B,OAAD,CAAX;AACD,GAjBD,EAiBG,CAACxB,WAAD,CAjBH,EArC6B,CAwD7B;AACA;;AACA,QAAM0B,eAAe,GAAG,MAAM;AAC5B,WACEjC,oBAAoB,IAAI,WAAxB,IACAA,oBAAoB,IAAI,YADxB,IAEAA,oBAAoB,IAAI,aAFxB,IAGAA,oBAAoB,IAAI,cAHxB,IAIAA,oBAAoB,IAAI,cAL1B;AAOD,GARD,CA1D6B,CAoE7B;;;AACA,QAAMkC,MAAM,GAAGlC,oBAAoB,CAACmC,QAArB,CAA8B,MAA9B,CAAf;AACA,QAAMC,KAAK,GAAGpC,oBAAoB,CAACqC,UAArB,CAAgC,KAAhC,CAAd;;AAEA,QAAMC,aAAa,GAAG,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAoD;AACxE,QAAIvC,oBAAoB,KAAK,EAA7B,EAAiC;AAC/B;AACA,UAAIiC,eAAe,EAAnB,EAAuB;AACrB;AACA;AACAf,8BAASsB,KAAT,CACE,CACE;AACEZ,UAAAA,YAAY,EAAEP,IAAI,CAACoB,OADrB;AAEEZ,UAAAA,YAAY,EAAEL,IAAI,CAACiB;AAFrB,SADF,CADF,EAOE;AAAEC,UAAAA,eAAe,EAAE;AAAnB,SAPF,EAQEH,WARF;AASD,OAZD,MAYO;AACL;AACA,cAAM;AAAEhB,UAAAA,CAAF;AAAKE,UAAAA;AAAL,YAAWkB,wBAAwB,CAACJ,WAAD,CAAzC;;AACA,YAAIH,KAAJ,EAAW;AACTZ,UAAAA,IAAI,CAACiB,OAAL,CAAaX,QAAb,CAAsB,CAACL,CAAvB;AACD;;AACD,YAAIS,MAAJ,EAAY;AACVb,UAAAA,IAAI,CAACoB,OAAL,CAAaX,QAAb,CAAsB,CAACP,CAAvB;AACD,SARI,CASL;AACA;;;AACAP,QAAAA,gBAAgB,CAACC,KAAjB,CAAuBa,QAAvB,CAAgC1B,QAAQ,CAACa,KAAT,GAAiBM,CAAjD;AACAP,QAAAA,gBAAgB,CAACI,MAAjB,CAAwBU,QAAxB,CAAiC1B,QAAQ,CAACgB,MAAT,GAAkBK,CAAnD;AACD;AACF,KA5BD,MA4BO;AACL;AACA,YAAM;AAAEF,QAAAA,CAAF;AAAKE,QAAAA;AAAL,UAAWc,WAAjB;AACA,YAAM;AAAEtB,QAAAA,KAAK,EAAE2B,YAAT;AAAuBxB,QAAAA,MAAM,EAAEyB;AAA/B,UAAiDzC,QAAvD;AACA,UAAI0C,QAAQ,GAAG,EAAf,CAJK,CAKL;;AACA,UAAIrB,CAAC,GAAGoB,aAAJ,GAAoB,KAAxB,EAA+B;AAC7BC,QAAAA,QAAQ,GAAGA,QAAQ,GAAG,KAAtB;AACD,OAFD,MAEO,IAAIrB,CAAC,GAAGoB,aAAJ,GAAoB,KAAxB,EAA+B;AACpCC,QAAAA,QAAQ,GAAGA,QAAQ,GAAG,QAAtB;AACD,OAFM,MAEA;AACLA,QAAAA,QAAQ,GAAGA,QAAQ,GAAG,QAAtB;AACD,OAZI,CAaL;;;AACA,UAAIvB,CAAC,GAAGqB,YAAJ,GAAmB,KAAvB,EAA8B;AAC5BE,QAAAA,QAAQ,GAAGA,QAAQ,GAAG,MAAtB;AACD,OAFD,MAEO,IAAIvB,CAAC,GAAGqB,YAAJ,GAAmB,KAAvB,EAA8B;AACnCE,QAAAA,QAAQ,GAAGA,QAAQ,GAAG,QAAtB;AACD,OAFM,MAEA;AACLA,QAAAA,QAAQ,GAAGA,QAAQ,GAAG,OAAtB;AACD;;AACD7C,MAAAA,uBAAuB,CAAC6C,QAAD,CAAvB;AACD;AACF,GApDD;;AAsDA,QAAMH,wBAAwB,GAAG,CAAC;AAChCf,IAAAA,YADgC;AAEhCC,IAAAA;AAFgC,GAAD,KAG4B;AAC3D,QAAIN,CAAC,GAAG,CAAR;AACA,QAAIE,CAAC,GAAG,CAAR;;AACA,QAAIG,YAAY,IAAIC,YAApB,EAAkC;AAChC,UAAID,YAAY,GAAGC,YAAnB,EAAiC;AAC/BN,QAAAA,CAAC,GAAG,CAACW,MAAM,GAAG,CAAC,CAAJ,GAAQ,CAAf,IAAoBN,YAAxB;;AACA,YAAIf,eAAJ,EAAqB;AACnBY,UAAAA,CAAC,GAAGF,CAAC,GAAGX,gBAAR;AACD,SAFD,MAEO;AACLa,UAAAA,CAAC,GAAG,CAACW,KAAK,GAAG,CAAC,CAAJ,GAAQ,CAAd,IAAmBP,YAAvB;AACD;AACF,OAPD,MAOO;AACLJ,QAAAA,CAAC,GAAG,CAACW,KAAK,GAAG,CAAC,CAAJ,GAAQ,CAAd,IAAmBP,YAAvB;;AACA,YAAIhB,eAAJ,EAAqB;AACnBU,UAAAA,CAAC,GAAGE,CAAC,GAAGb,gBAAR;AACD,SAFD,MAEO;AACLW,UAAAA,CAAC,GAAG,CAACW,MAAM,GAAG,CAAC,CAAJ,GAAQ,CAAf,IAAoBN,YAAxB;AACD;AACF;AACF;;AACD,WAAO;AAAEL,MAAAA,CAAF;AAAKE,MAAAA;AAAL,KAAP;AACD,GAxBD;;AA0BA,QAAMsB,gBAAgB,GACpBR,WADuB,IAEpB;AACH;AACA,QAAIN,eAAe,EAAnB,EAAuB;AACrB;AACAN,MAAAA,eAAe,CAACY,WAAD,CAAf;AACD,KAHD,MAGO;AACL;AACAS,MAAAA,iBAAiB,CAACT,WAAD,CAAjB;AACD,KARE,CASH;;;AACAtC,IAAAA,uBAAuB,CAAC,EAAD,CAAvB;AACD,GAbD;;AAeA,QAAMgD,oBAAoB,GAAG,CAAC;AAC5BV,IAAAA;AAD4B,GAAD,KAEQ;AACnC;AACA;AACA,QAAIA,WAAW,CAACW,KAAZ,KAAsBC,iCAAMC,GAAhC,EAAqC;AACnCL,MAAAA,gBAAgB,CAACR,WAAD,CAAhB;AACD;AACF,GARD;;AAUA,QAAMZ,eAAe,GAAG,CAAC;AACvBC,IAAAA,YADuB;AAEvBC,IAAAA;AAFuB,GAAD,KAK+B;AACrD;AACA,QAAIwB,KAAK,GAAG5C,cAAc,CAACc,CAAf,GAAmBK,YAA/B,CAFqD,CAGrD;;AACA,QAAIyB,KAAK,IAAI9C,WAAW,CAACgB,CAAzB,EAA4B;AAC1B;AACA8B,MAAAA,KAAK,GAAG9C,WAAW,CAACgB,CAApB;AACD,KAHD,CAIA;AAJA,SAKK,IAAI8B,KAAK,GAAGjD,QAAQ,CAACa,KAAjB,GAAyBV,WAAW,CAACU,KAAZ,GAAoBV,WAAW,CAACgB,CAA7D,EAAgE;AACnE;AACA,UAAI+B,WAAW,GAAG/C,WAAW,CAACgB,CAAZ,GAAgBhB,WAAW,CAACU,KAA5B,GAAoCb,QAAQ,CAACa,KAA/D;AACAoC,MAAAA,KAAK,GAAGC,WAAR;AACD,KAJI,MAIE,CACL;AACD,KAfoD,CAgBrD;;;AACA,QAAIC,KAAK,GAAG9C,cAAc,CAACgB,CAAf,GAAmBI,YAA/B,CAjBqD,CAkBrD;;AACA,QAAI0B,KAAK,IAAIhD,WAAW,CAACkB,CAAzB,EAA4B;AAC1B;AACA8B,MAAAA,KAAK,GAAGhD,WAAW,CAACkB,CAApB;AACD,KAHD,CAIA;AAJA,SAKK,IAAI8B,KAAK,GAAGnD,QAAQ,CAACgB,MAAjB,GAA0Bb,WAAW,CAACa,MAAZ,GAAqBb,WAAW,CAACkB,CAA/D,EAAkE;AACrE;AACA,UAAI+B,WAAW,GAAGjD,WAAW,CAACkB,CAAZ,GAAgBlB,WAAW,CAACa,MAA5B,GAAqChB,QAAQ,CAACgB,MAAhE;AACAmC,MAAAA,KAAK,GAAGC,WAAR;AACD,KAJI,MAIE,CACL;AACD,KA9BoD,CA+BrD;;;AACAnC,IAAAA,IAAI,CAACoB,OAAL,CAAaX,QAAb,CAAsB,CAAtB;AACAN,IAAAA,IAAI,CAACiB,OAAL,CAAaX,QAAb,CAAsB,CAAtB;AACApB,IAAAA,iBAAiB,CAAC;AAAEa,MAAAA,CAAC,EAAE8B,KAAL;AAAY5B,MAAAA,CAAC,EAAE8B;AAAf,KAAD,CAAjB;AACD,GAxCD;;AA0CA,QAAMP,iBAAiB,GAAG,CAAC;AACzBpB,IAAAA,YADyB;AAEzBC,IAAAA;AAFyB,GAAD,KAK6B;AACrD;AACA;AACA,UAAM;AAAEZ,MAAAA,KAAK,EAAEwC,QAAT;AAAmBrC,MAAAA,MAAM,EAAEsC;AAA3B,QAAyCnD,WAA/C;AACA,UAAM;AAAEU,MAAAA,KAAK,EAAE0C,QAAT;AAAmBvC,MAAAA,MAAM,EAAEwC;AAA3B,QAAyC9C,qBAA/C;AACA,UAAM;AAAES,MAAAA,CAAF;AAAKE,MAAAA;AAAL,QAAWkB,wBAAwB,CAAC;AAAEf,MAAAA,YAAF;AAAgBC,MAAAA;AAAhB,KAAD,CAAzC;AACA,UAAMgC,aAAa,GAAGzD,QAAQ,CAACa,KAAT,GAAiBM,CAAvC;AACA,UAAMuC,cAAc,GAAG1D,QAAQ,CAACgB,MAAT,GAAkBK,CAAzC;AACA,QAAIsC,WAAW,GAAGD,cAAlB;AACA,QAAIE,UAAU,GAAGH,aAAjB,CATqD,CAUrD;AACA;;AACA,QAAIC,cAAc,GAAGJ,SAArB,EAAgC;AAC9BK,MAAAA,WAAW,GAAGL,SAAd;AACA,UAAI7C,eAAJ,EAAqBmD,UAAU,GAAGD,WAAW,GAAGnD,gBAA3B;AACtB,KAHD,MAGO,IAAIkD,cAAc,GAAGF,SAArB,EAAgC;AACrCG,MAAAA,WAAW,GAAGH,SAAd;AACA,UAAI/C,eAAJ,EAAqBmD,UAAU,GAAGD,WAAW,GAAGnD,gBAA3B;AACtB;;AACD,QAAIiD,aAAa,GAAGJ,QAApB,EAA8B;AAC5BO,MAAAA,UAAU,GAAGP,QAAb;AACA,UAAI5C,eAAJ,EAAqBkD,WAAW,GAAGC,UAAU,GAAGpD,gBAA3B;AACtB,KAHD,MAGO,IAAIiD,aAAa,GAAGF,QAApB,EAA8B;AACnCK,MAAAA,UAAU,GAAGL,QAAb;AACA,UAAI9C,eAAJ,EAAqBkD,WAAW,GAAGC,UAAU,GAAGpD,gBAA3B;AACtB,KAzBoD,CA0BrD;;;AACAF,IAAAA,iBAAiB,CAAC;AAChBa,MAAAA,CAAC,EAAEd,cAAc,CAACc,CAAf,IAAoBW,MAAM,GAAG,CAACX,CAAJ,GAAQ,CAAlC,CADa;AAEhBE,MAAAA,CAAC,EAAEhB,cAAc,CAACgB,CAAf,IAAoBW,KAAK,GAAG,CAACX,CAAJ,GAAQ,CAAjC;AAFa,KAAD,CAAjB,CA3BqD,CA+BrD;;AACAJ,IAAAA,IAAI,CAACoB,OAAL,CAAaX,QAAb,CAAsB,CAAtB;AACAN,IAAAA,IAAI,CAACiB,OAAL,CAAaX,QAAb,CAAsB,CAAtB,EAjCqD,CAkCrD;;AACAzB,IAAAA,WAAW,CAAC;AACVe,MAAAA,MAAM,EAAE2C,WADE;AAEV9C,MAAAA,KAAK,EAAE+C;AAFG,KAAD,CAAX;AAID,GA5CD;;AA8CA,sBACE,oBAAC,iDAAD;AAAwB,IAAA,KAAK,EAAEC,MAAM,CAACC;AAAtC,kBACE,oBAAC,4CAAD;AACE,IAAA,cAAc,EAAE5B,aADlB;AAEE,IAAA,oBAAoB,EAAG6B,CAAD,IAAOlB,oBAAoB,CAACkB,CAAD;AAFnD,kBAIE,oBAAC,qBAAD,CAAU,IAAV;AACE,IAAA,KAAK,EAAE,CACLF,MAAM,CAACG,OADF,EAELpD,gBAFK,EAGL;AACEqD,MAAAA,SAAS,EAAE,CACT;AAAEC,QAAAA,UAAU,EAAEpD,sBAASqD,GAAT,CAAalD,IAAI,CAACoB,OAAlB,EAA2BhC,cAAc,CAACc,CAA1C;AAAd,OADS,EAET;AAAEiD,QAAAA,UAAU,EAAEtD,sBAASqD,GAAT,CAAa/C,IAAI,CAACiB,OAAlB,EAA2BhC,cAAc,CAACgB,CAA1C;AAAd,OAFS;AADb,KAHK;AADT,KAaI;AACA5B,EAAAA,kBAAkB,CAAC4E,GAAnB,CAAwBC,QAAD,IAAc;AACnC,wBACE,oBAAC,iBAAD;AAAM,MAAA,KAAK,EAAET,MAAM,CAACU,UAApB;AAAgC,MAAA,GAAG,EAAED;AAArC,OACG5E,gBAAgB,CAAC2E,GAAjB,CAAsBG,QAAD,IAAc;AAClC,YAAMC,GAAG,GAAGH,QAAQ,GAAGE,QAAvB;AACA,0BACE,oBAAC,iBAAD;AAAM,QAAA,KAAK,EAAE,CAACX,MAAM,CAACa,cAAR,CAAb;AAAsC,QAAA,GAAG,EAAED;AAA3C,SAEI;AACA;AACAA,MAAAA,GAAG,IAAI,SAAP,IACAA,GAAG,IAAI,UADP,IAEAA,GAAG,IAAI,YAFP,IAGAA,GAAG,IAAI,aAHP,gBAIE,oBAAC,iBAAD;AACE,QAAA,KAAK,EAAE,CACLZ,MAAM,CAACc,YADF,EAELL,QAAQ,IAAI,KAAZ,GACI;AAAEM,UAAAA,GAAG,EAAE,CAAC,CAAR;AAAWC,UAAAA,cAAc,EAAE;AAA3B,SADJ,GAEI;AAAEC,UAAAA,MAAM,EAAE,CAAC,CAAX;AAAcC,UAAAA,iBAAiB,EAAE;AAAjC,SAJC,EAKLP,QAAQ,IAAI,MAAZ,GACI;AAAEQ,UAAAA,IAAI,EAAE,CAAC,CAAT;AAAYC,UAAAA,eAAe,EAAE;AAA7B,SADJ,GAEI;AAAEC,UAAAA,KAAK,EAAE,CAAC,CAAV;AAAaC,UAAAA,gBAAgB,EAAE;AAA/B,SAPC;AADT,QAJF,GAeI,IAnBR,CADF;AAwBD,KA1BA,CADH,CADF;AA+BD,GAhCD,CAdJ,CAJF,CADF,CADF;AA0DD,CAnUD;;;;AAuUA,MAAMtB,MAAM,GAAGuB,wBAAWC,MAAX,CAAkB;AAC/BvB,EAAAA,SAAS,EAAE;AACT9C,IAAAA,MAAM,EAAE,MADC;AAETH,IAAAA,KAAK,EAAE,MAFE;AAGT6B,IAAAA,QAAQ,EAAE;AAHD,GADoB;AAM/BsB,EAAAA,OAAO,EAAE;AACPhD,IAAAA,MAAM,EAAE,EADD;AAEPH,IAAAA,KAAK,EAAE,EAFA;AAGPyE,IAAAA,eAAe,EAAE,WAHV;AAIPC,IAAAA,WAAW,EAAE,WAJN;AAKPC,IAAAA,WAAW,EAAE;AALN,GANsB;AAa/BjB,EAAAA,UAAU,EAAE;AACVkB,IAAAA,aAAa,EAAE,KADL;AAEVC,IAAAA,IAAI,EAAE;AAFI,GAbmB;AAiB/BhB,EAAAA,cAAc,EAAE;AACdgB,IAAAA,IAAI,EAAE,CADQ;AAEdF,IAAAA,WAAW,EAAE,GAFC;AAGdD,IAAAA,WAAW,EAAE,WAHC;AAIdI,IAAAA,cAAc,EAAE,QAJF;AAKdC,IAAAA,UAAU,EAAE;AALE,GAjBe;AAwB/BjB,EAAAA,YAAY,EAAE;AACZjC,IAAAA,QAAQ,EAAE,UADE;AAEZ6C,IAAAA,WAAW,EAAE,SAFD;AAGZvE,IAAAA,MAAM,EAAE,EAHI;AAIZH,IAAAA,KAAK,EAAE;AAJK;AAxBiB,CAAlB,CAAf","sourcesContent":["import * as React from \"react\";\r\nimport {\r\n  Animated,\r\n  StyleSheet,\r\n  View,\r\n  TouchableOpacity,\r\n  requireNativeComponent,\r\n  Platform,\r\n  ViewPropTypes,\r\n} from \"react-native\";\r\nimport _ from \"lodash\";\r\nimport { useRecoilState } from \"recoil\";\r\nimport { cropSizeState, imageBoundsState, accumulatedPanState } from \"./Store\";\r\nimport {\r\n  GestureHandlerRootView,\r\n  PanGestureHandler,\r\n  PanGestureHandlerGestureEvent,\r\n  State,\r\n} from \"react-native-gesture-handler\";\r\nimport { useContext } from \"react\";\r\nimport { EditorContext } from \"./index\";\r\n\r\nconst horizontalSections = [\"top\", \"middle\", \"bottom\"];\r\nconst verticalSections = [\"left\", \"middle\", \"right\"];\r\n\r\nconst ImageCropOverlay = () => {\r\n  // Record which section of the fram window has been pressed\r\n  // this determines whether it is a translation or scaling gesture\r\n  const [selectedFrameSection, setSelectedFrameSection] = React.useState(\"\");\r\n\r\n  // Shared state and bits passed through recoil to avoid prop drilling\r\n  const [cropSize, setCropSize] = useRecoilState(cropSizeState);\r\n  const [imageBounds] = useRecoilState(imageBoundsState);\r\n  const [accumulatedPan, setAccumluatedPan] =\r\n    useRecoilState(accumulatedPanState);\r\n  // Editor context\r\n  const { fixedAspectRatio, lockAspectRatio, minimumCropDimensions } =\r\n    useContext(EditorContext);\r\n\r\n  const [animatedCropSize] = React.useState({\r\n    width: new Animated.Value(cropSize.width),\r\n    height: new Animated.Value(cropSize.height),\r\n  });\r\n\r\n  // pan X and Y values to track the current delta of the pan\r\n  // in both directions - this should be zeroed out on release\r\n  // and the delta added onto the accumulatedPan state\r\n  const panX = React.useRef(new Animated.Value(imageBounds.x));\r\n  const panY = React.useRef(new Animated.Value(imageBounds.y));\r\n\r\n  React.useEffect(() => {\r\n    // Move the pan to the origin and check the bounds so it clicks to\r\n    // the corner of the image\r\n    checkCropBounds({\r\n      translationX: 0,\r\n      translationY: 0,\r\n    });\r\n    // When the crop size updates make sure the animated value does too!\r\n    animatedCropSize.height.setValue(cropSize.height);\r\n    animatedCropSize.width.setValue(cropSize.width);\r\n  }, [cropSize]);\r\n\r\n  React.useEffect(() => {\r\n    // Update the size of the crop window based on the new image bounds\r\n    let newSize = { width: 0, height: 0 };\r\n    const { width, height } = imageBounds;\r\n    const imageAspectRatio = width / height;\r\n    // Then check if the cropping aspect ratio is smaller\r\n    if (fixedAspectRatio < imageAspectRatio) {\r\n      // If so calculate the size so its not greater than the image width\r\n      newSize.height = height;\r\n      newSize.width = height * fixedAspectRatio;\r\n    } else {\r\n      // else, calculate the size so its not greater than the image height\r\n      newSize.width = width;\r\n      newSize.height = width / fixedAspectRatio;\r\n    }\r\n    // Set the size of the crop overlay\r\n    setCropSize(newSize);\r\n  }, [imageBounds]);\r\n\r\n  // Function that sets which sections allow for translation when\r\n  // pressed\r\n  const isMovingSection = () => {\r\n    return (\r\n      selectedFrameSection == \"topmiddle\" ||\r\n      selectedFrameSection == \"middleleft\" ||\r\n      selectedFrameSection == \"middleright\" ||\r\n      selectedFrameSection == \"middlemiddle\" ||\r\n      selectedFrameSection == \"bottommiddle\"\r\n    );\r\n  };\r\n\r\n  // Check what resizing / translation needs to be performed based on which section was pressed\r\n  const isLeft = selectedFrameSection.endsWith(\"left\");\r\n  const isTop = selectedFrameSection.startsWith(\"top\");\r\n\r\n  const onOverlayMove = ({ nativeEvent }: PanGestureHandlerGestureEvent) => {\r\n    if (selectedFrameSection !== \"\") {\r\n      // Check if the section pressed is one to translate the crop window or not\r\n      if (isMovingSection()) {\r\n        // If it is then use an animated event to directly pass the tranlation\r\n        // to the pan refs\r\n        Animated.event(\r\n          [\r\n            {\r\n              translationX: panX.current,\r\n              translationY: panY.current,\r\n            },\r\n          ],\r\n          { useNativeDriver: false }\r\n        )(nativeEvent);\r\n      } else {\r\n        // Else its a scaling operation\r\n        const { x, y } = getTargetCropFrameBounds(nativeEvent);\r\n        if (isTop) {\r\n          panY.current.setValue(-y);\r\n        }\r\n        if (isLeft) {\r\n          panX.current.setValue(-x);\r\n        }\r\n        // Finally update the animated width to the values the crop\r\n        // window has been resized to\r\n        animatedCropSize.width.setValue(cropSize.width + x);\r\n        animatedCropSize.height.setValue(cropSize.height + y);\r\n      }\r\n    } else {\r\n      // We need to set which section has been pressed\r\n      const { x, y } = nativeEvent;\r\n      const { width: initialWidth, height: initialHeight } = cropSize;\r\n      let position = \"\";\r\n      // Figure out where we pressed vertically\r\n      if (y / initialHeight < 0.333) {\r\n        position = position + \"top\";\r\n      } else if (y / initialHeight < 0.667) {\r\n        position = position + \"middle\";\r\n      } else {\r\n        position = position + \"bottom\";\r\n      }\r\n      // Figure out where we pressed horizontally\r\n      if (x / initialWidth < 0.333) {\r\n        position = position + \"left\";\r\n      } else if (x / initialWidth < 0.667) {\r\n        position = position + \"middle\";\r\n      } else {\r\n        position = position + \"right\";\r\n      }\r\n      setSelectedFrameSection(position);\r\n    }\r\n  };\r\n\r\n  const getTargetCropFrameBounds = ({\r\n    translationX,\r\n    translationY,\r\n  }: Partial<PanGestureHandlerGestureEvent[\"nativeEvent\"]>) => {\r\n    let x = 0;\r\n    let y = 0;\r\n    if (translationX && translationY) {\r\n      if (translationX < translationY) {\r\n        x = (isLeft ? -1 : 1) * translationX;\r\n        if (lockAspectRatio) {\r\n          y = x / fixedAspectRatio;\r\n        } else {\r\n          y = (isTop ? -1 : 1) * translationY;\r\n        }\r\n      } else {\r\n        y = (isTop ? -1 : 1) * translationY;\r\n        if (lockAspectRatio) {\r\n          x = y * fixedAspectRatio;\r\n        } else {\r\n          x = (isLeft ? -1 : 1) * translationX;\r\n        }\r\n      }\r\n    }\r\n    return { x, y };\r\n  };\r\n\r\n  const onOverlayRelease = (\r\n    nativeEvent: PanGestureHandlerGestureEvent[\"nativeEvent\"]\r\n  ) => {\r\n    // Check if the section pressed is one to translate the crop window or not\r\n    if (isMovingSection()) {\r\n      // Ensure the cropping overlay has not been moved outside of the allowed bounds\r\n      checkCropBounds(nativeEvent);\r\n    } else {\r\n      // Else its a scaling op - check that the resizing didnt take it out of bounds\r\n      checkResizeBounds(nativeEvent);\r\n    }\r\n    // Disable the pan responder so the section tiles can register being pressed again\r\n    setSelectedFrameSection(\"\");\r\n  };\r\n\r\n  const onHandlerStateChange = ({\r\n    nativeEvent,\r\n  }: PanGestureHandlerGestureEvent) => {\r\n    // Handle any state changes from the pan gesture handler\r\n    // only looking at when the touch ends atm\r\n    if (nativeEvent.state === State.END) {\r\n      onOverlayRelease(nativeEvent);\r\n    }\r\n  };\r\n\r\n  const checkCropBounds = ({\r\n    translationX,\r\n    translationY,\r\n  }:\r\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\r\n    | { translationX: number; translationY: number }) => {\r\n    // Check if the pan in the x direction exceeds the bounds\r\n    let accDx = accumulatedPan.x + translationX;\r\n    // Is the new x pos less than zero?\r\n    if (accDx <= imageBounds.x) {\r\n      // Then set it to be zero and set the pan to zero too\r\n      accDx = imageBounds.x;\r\n    }\r\n    // Is the new x pos plus crop width going to exceed the right hand bound\r\n    else if (accDx + cropSize.width > imageBounds.width + imageBounds.x) {\r\n      // Then set the x pos so the crop frame touches the right hand edge\r\n      let limitedXPos = imageBounds.x + imageBounds.width - cropSize.width;\r\n      accDx = limitedXPos;\r\n    } else {\r\n      // It's somewhere in between - no formatting required\r\n    }\r\n    // Check if the pan in the y direction exceeds the bounds\r\n    let accDy = accumulatedPan.y + translationY;\r\n    // Is the new y pos less the top edge?\r\n    if (accDy <= imageBounds.y) {\r\n      // Then set it to be zero and set the pan to zero too\r\n      accDy = imageBounds.y;\r\n    }\r\n    // Is the new y pos plus crop height going to exceed the bottom bound\r\n    else if (accDy + cropSize.height > imageBounds.height + imageBounds.y) {\r\n      // Then set the y pos so the crop frame touches the bottom edge\r\n      let limitedYPos = imageBounds.y + imageBounds.height - cropSize.height;\r\n      accDy = limitedYPos;\r\n    } else {\r\n      // It's somewhere in between - no formatting required\r\n    }\r\n    // Record the accumulated pan and reset the pan refs to zero\r\n    panX.current.setValue(0);\r\n    panY.current.setValue(0);\r\n    setAccumluatedPan({ x: accDx, y: accDy });\r\n  };\r\n\r\n  const checkResizeBounds = ({\r\n    translationX,\r\n    translationY,\r\n  }:\r\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\r\n    | { translationX: number; translationY: number }) => {\r\n    // Check we haven't gone out of bounds when resizing - allow it to be\r\n    // resized up to the appropriate bounds if so\r\n    const { width: maxWidth, height: maxHeight } = imageBounds;\r\n    const { width: minWidth, height: minHeight } = minimumCropDimensions;\r\n    const { x, y } = getTargetCropFrameBounds({ translationX, translationY });\r\n    const animatedWidth = cropSize.width + x;\r\n    const animatedHeight = cropSize.height + y;\r\n    let finalHeight = animatedHeight;\r\n    let finalWidth = animatedWidth;\r\n    // Ensure the width / height does not exceed the boundaries -\r\n    // resize to the max it can be if so\r\n    if (animatedHeight > maxHeight) {\r\n      finalHeight = maxHeight;\r\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\r\n    } else if (animatedHeight < minHeight) {\r\n      finalHeight = minHeight;\r\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\r\n    }\r\n    if (animatedWidth > maxWidth) {\r\n      finalWidth = maxWidth;\r\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\r\n    } else if (animatedWidth < minWidth) {\r\n      finalWidth = minWidth;\r\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\r\n    }\r\n    // Update the accumulated pan with the delta from the pan refs\r\n    setAccumluatedPan({\r\n      x: accumulatedPan.x + (isLeft ? -x : 0),\r\n      y: accumulatedPan.y + (isTop ? -y : 0),\r\n    });\r\n    // Zero out the pan refs\r\n    panX.current.setValue(0);\r\n    panY.current.setValue(0);\r\n    // Update the crop size to the size after resizing\r\n    setCropSize({\r\n      height: finalHeight,\r\n      width: finalWidth,\r\n    });\r\n  };\r\n\r\n  return (\r\n    <GestureHandlerRootView style={styles.container}>\r\n      <PanGestureHandler\r\n        onGestureEvent={onOverlayMove}\r\n        onHandlerStateChange={(e) => onHandlerStateChange(e)}\r\n      >\r\n        <Animated.View\r\n          style={[\r\n            styles.overlay,\r\n            animatedCropSize,\r\n            {\r\n              transform: [\r\n                { translateX: Animated.add(panX.current, accumulatedPan.x) },\r\n                { translateY: Animated.add(panY.current, accumulatedPan.y) },\r\n              ],\r\n            },\r\n          ]}\r\n        >\r\n          {\r\n            // For reendering out each section of the crop overlay frame\r\n            horizontalSections.map((hsection) => {\r\n              return (\r\n                <View style={styles.sectionRow} key={hsection}>\r\n                  {verticalSections.map((vsection) => {\r\n                    const key = hsection + vsection;\r\n                    return (\r\n                      <View style={[styles.defaultSection]} key={key}>\r\n                        {\r\n                          // Add the corner markers to the topleft,\r\n                          // topright, bottomleft and bottomright corners to indicate resizing\r\n                          key == \"topleft\" ||\r\n                          key == \"topright\" ||\r\n                          key == \"bottomleft\" ||\r\n                          key == \"bottomright\" ? (\r\n                            <View\r\n                              style={[\r\n                                styles.cornerMarker,\r\n                                hsection == \"top\"\r\n                                  ? { top: -4, borderTopWidth: 7 }\r\n                                  : { bottom: -4, borderBottomWidth: 7 },\r\n                                vsection == \"left\"\r\n                                  ? { left: -4, borderLeftWidth: 7 }\r\n                                  : { right: -4, borderRightWidth: 7 },\r\n                              ]}\r\n                            />\r\n                          ) : null\r\n                        }\r\n                      </View>\r\n                    );\r\n                  })}\r\n                </View>\r\n              );\r\n            })\r\n          }\r\n        </Animated.View>\r\n      </PanGestureHandler>\r\n    </GestureHandlerRootView>\r\n  );\r\n};\r\n\r\nexport { ImageCropOverlay };\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    height: \"100%\",\r\n    width: \"100%\",\r\n    position: \"absolute\",\r\n  },\r\n  overlay: {\r\n    height: 40,\r\n    width: 40,\r\n    backgroundColor: \"#33333355\",\r\n    borderColor: \"#ffffff88\",\r\n    borderWidth: 1,\r\n  },\r\n  sectionRow: {\r\n    flexDirection: \"row\",\r\n    flex: 1,\r\n  },\r\n  defaultSection: {\r\n    flex: 1,\r\n    borderWidth: 0.5,\r\n    borderColor: \"#ffffff88\",\r\n    justifyContent: \"center\",\r\n    alignItems: \"center\",\r\n  },\r\n  cornerMarker: {\r\n    position: \"absolute\",\r\n    borderColor: \"#ffffff\",\r\n    height: 30,\r\n    width: 30,\r\n  },\r\n});\r\n"]}