{"version":3,"sources":["ImageCropOverlay.tsx"],"names":["React","Animated","StyleSheet","View","useRecoilState","cropSizeState","imageBoundsState","accumulatedPanState","GestureHandlerRootView","PanGestureHandler","State","useContext","EditorContext","horizontalSections","verticalSections","ImageCropOverlay","selectedFrameSection","setSelectedFrameSection","useState","cropSize","setCropSize","imageBounds","accumulatedPan","setAccumluatedPan","fixedAspectRatio","lockAspectRatio","minimumCropDimensions","animatedCropSize","width","Value","height","panX","useRef","x","panY","y","useEffect","checkCropBounds","translationX","translationY","setValue","newSize","imageAspectRatio","isMovingSection","isLeft","endsWith","isTop","startsWith","onOverlayMove","nativeEvent","event","current","useNativeDriver","getTargetCropFrameBounds","initialWidth","initialHeight","position","onOverlayRelease","checkResizeBounds","onHandlerStateChange","state","END","accDx","limitedXPos","accDy","limitedYPos","maxWidth","maxHeight","minWidth","minHeight","animatedWidth","animatedHeight","finalHeight","finalWidth","styles","container","e","overlay","transform","translateX","add","translateY","map","hsection","sectionRow","vsection","key","defaultSection","cornerMarker","top","borderTopWidth","bottom","borderBottomWidth","left","borderLeftWidth","right","borderRightWidth","create","backgroundColor","borderColor","borderWidth","flexDirection","flex","justifyContent","alignItems"],"mappings":"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","sourcesContent":["import * as React from \"react\";\r\nimport {\r\n  Animated,\r\n  StyleSheet,\r\n  View,\r\n  TouchableOpacity,\r\n  requireNativeComponent,\r\n  Platform,\r\n  ViewPropTypes,\r\n} from \"react-native\";\r\nimport _ from \"lodash\";\r\nimport { useRecoilState } from \"recoil\";\r\nimport { cropSizeState, imageBoundsState, accumulatedPanState } from \"./Store\";\r\nimport {\r\n  GestureHandlerRootView,\r\n  PanGestureHandler,\r\n  PanGestureHandlerGestureEvent,\r\n  State,\r\n} from \"react-native-gesture-handler\";\r\nimport { useContext } from \"react\";\r\nimport { EditorContext } from \"./index\";\r\n\r\nconst horizontalSections = [\"top\", \"middle\", \"bottom\"];\r\nconst verticalSections = [\"left\", \"middle\", \"right\"];\r\n\r\nconst ImageCropOverlay = () => {\r\n  // Record which section of the fram window has been pressed\r\n  // this determines whether it is a translation or scaling gesture\r\n  const [selectedFrameSection, setSelectedFrameSection] = React.useState(\"\");\r\n\r\n  // Shared state and bits passed through recoil to avoid prop drilling\r\n  const [cropSize, setCropSize] = useRecoilState(cropSizeState);\r\n  const [imageBounds] = useRecoilState(imageBoundsState);\r\n  const [accumulatedPan, setAccumluatedPan] =\r\n    useRecoilState(accumulatedPanState);\r\n  // Editor context\r\n  const { fixedAspectRatio, lockAspectRatio, minimumCropDimensions } =\r\n    useContext(EditorContext);\r\n\r\n  const [animatedCropSize] = React.useState({\r\n    width: new Animated.Value(cropSize.width),\r\n    height: new Animated.Value(cropSize.height),\r\n  });\r\n\r\n  // pan X and Y values to track the current delta of the pan\r\n  // in both directions - this should be zeroed out on release\r\n  // and the delta added onto the accumulatedPan state\r\n  const panX = React.useRef(new Animated.Value(imageBounds.x));\r\n  const panY = React.useRef(new Animated.Value(imageBounds.y));\r\n\r\n  React.useEffect(() => {\r\n    // Move the pan to the origin and check the bounds so it clicks to\r\n    // the corner of the image\r\n    checkCropBounds({\r\n      translationX: 0,\r\n      translationY: 0,\r\n    });\r\n    // When the crop size updates make sure the animated value does too!\r\n    animatedCropSize.height.setValue(cropSize.height);\r\n    animatedCropSize.width.setValue(cropSize.width);\r\n  }, [cropSize]);\r\n\r\n  React.useEffect(() => {\r\n    // Update the size of the crop window based on the new image bounds\r\n    let newSize = { width: 0, height: 0 };\r\n    const { width, height } = imageBounds;\r\n    const imageAspectRatio = width / height;\r\n    // Then check if the cropping aspect ratio is smaller\r\n    if (fixedAspectRatio < imageAspectRatio) {\r\n      // If so calculate the size so its not greater than the image width\r\n      newSize.height = height;\r\n      newSize.width = height * fixedAspectRatio;\r\n    } else {\r\n      // else, calculate the size so its not greater than the image height\r\n      newSize.width = width;\r\n      newSize.height = width / fixedAspectRatio;\r\n    }\r\n    // Set the size of the crop overlay\r\n    setCropSize(newSize);\r\n  }, [imageBounds]);\r\n\r\n  // Function that sets which sections allow for translation when\r\n  // pressed\r\n  const isMovingSection = () => {\r\n    return (\r\n      selectedFrameSection == \"topmiddle\" ||\r\n      selectedFrameSection == \"middleleft\" ||\r\n      selectedFrameSection == \"middleright\" ||\r\n      selectedFrameSection == \"middlemiddle\" ||\r\n      selectedFrameSection == \"bottommiddle\"\r\n    );\r\n  };\r\n\r\n  // Check what resizing / translation needs to be performed based on which section was pressed\r\n  const isLeft = selectedFrameSection.endsWith(\"left\");\r\n  const isTop = selectedFrameSection.startsWith(\"top\");\r\n\r\n  const onOverlayMove = ({ nativeEvent }: PanGestureHandlerGestureEvent) => {\r\n    if (selectedFrameSection !== \"\") {\r\n      // Check if the section pressed is one to translate the crop window or not\r\n      if (isMovingSection()) {\r\n        // If it is then use an animated event to directly pass the tranlation\r\n        // to the pan refs\r\n        Animated.event(\r\n          [\r\n            {\r\n              translationX: panX.current,\r\n              translationY: panY.current,\r\n            },\r\n          ],\r\n          { useNativeDriver: false }\r\n        )(nativeEvent);\r\n      } else {\r\n        // Else its a scaling operation\r\n        const { x, y } = getTargetCropFrameBounds(nativeEvent);\r\n        if (isTop) {\r\n          panY.current.setValue(-y);\r\n        }\r\n        if (isLeft) {\r\n          panX.current.setValue(-x);\r\n        }\r\n        // Finally update the animated width to the values the crop\r\n        // window has been resized to\r\n        animatedCropSize.width.setValue(cropSize.width + x);\r\n        animatedCropSize.height.setValue(cropSize.height + y);\r\n      }\r\n    } else {\r\n      // We need to set which section has been pressed\r\n      const { x, y } = nativeEvent;\r\n      const { width: initialWidth, height: initialHeight } = cropSize;\r\n      let position = \"\";\r\n      // Figure out where we pressed vertically\r\n      if (y / initialHeight < 0.333) {\r\n        position = position + \"top\";\r\n      } else if (y / initialHeight < 0.667) {\r\n        position = position + \"middle\";\r\n      } else {\r\n        position = position + \"bottom\";\r\n      }\r\n      // Figure out where we pressed horizontally\r\n      if (x / initialWidth < 0.333) {\r\n        position = position + \"left\";\r\n      } else if (x / initialWidth < 0.667) {\r\n        position = position + \"middle\";\r\n      } else {\r\n        position = position + \"right\";\r\n      }\r\n      setSelectedFrameSection(position);\r\n    }\r\n  };\r\n\r\n  const getTargetCropFrameBounds = ({\r\n    translationX,\r\n    translationY,\r\n  }: Partial<PanGestureHandlerGestureEvent[\"nativeEvent\"]>) => {\r\n    let x = 0;\r\n    let y = 0;\r\n    if (translationX && translationY) {\r\n      if (translationX < translationY) {\r\n        x = (isLeft ? -1 : 1) * translationX;\r\n        if (lockAspectRatio) {\r\n          y = x / fixedAspectRatio;\r\n        } else {\r\n          y = (isTop ? -1 : 1) * translationY;\r\n        }\r\n      } else {\r\n        y = (isTop ? -1 : 1) * translationY;\r\n        if (lockAspectRatio) {\r\n          x = y * fixedAspectRatio;\r\n        } else {\r\n          x = (isLeft ? -1 : 1) * translationX;\r\n        }\r\n      }\r\n    }\r\n    return { x, y };\r\n  };\r\n\r\n  const onOverlayRelease = (\r\n    nativeEvent: PanGestureHandlerGestureEvent[\"nativeEvent\"]\r\n  ) => {\r\n    // Check if the section pressed is one to translate the crop window or not\r\n    if (isMovingSection()) {\r\n      // Ensure the cropping overlay has not been moved outside of the allowed bounds\r\n      checkCropBounds(nativeEvent);\r\n    } else {\r\n      // Else its a scaling op - check that the resizing didnt take it out of bounds\r\n      checkResizeBounds(nativeEvent);\r\n    }\r\n    // Disable the pan responder so the section tiles can register being pressed again\r\n    setSelectedFrameSection(\"\");\r\n  };\r\n\r\n  const onHandlerStateChange = ({\r\n    nativeEvent,\r\n  }: PanGestureHandlerGestureEvent) => {\r\n    // Handle any state changes from the pan gesture handler\r\n    // only looking at when the touch ends atm\r\n    if (nativeEvent.state === State.END) {\r\n      onOverlayRelease(nativeEvent);\r\n    }\r\n  };\r\n\r\n  const checkCropBounds = ({\r\n    translationX,\r\n    translationY,\r\n  }:\r\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\r\n    | { translationX: number; translationY: number }) => {\r\n    // Check if the pan in the x direction exceeds the bounds\r\n    let accDx = accumulatedPan.x + translationX;\r\n    // Is the new x pos less than zero?\r\n    if (accDx <= imageBounds.x) {\r\n      // Then set it to be zero and set the pan to zero too\r\n      accDx = imageBounds.x;\r\n    }\r\n    // Is the new x pos plus crop width going to exceed the right hand bound\r\n    else if (accDx + cropSize.width > imageBounds.width + imageBounds.x) {\r\n      // Then set the x pos so the crop frame touches the right hand edge\r\n      let limitedXPos = imageBounds.x + imageBounds.width - cropSize.width;\r\n      accDx = limitedXPos;\r\n    } else {\r\n      // It's somewhere in between - no formatting required\r\n    }\r\n    // Check if the pan in the y direction exceeds the bounds\r\n    let accDy = accumulatedPan.y + translationY;\r\n    // Is the new y pos less the top edge?\r\n    if (accDy <= imageBounds.y) {\r\n      // Then set it to be zero and set the pan to zero too\r\n      accDy = imageBounds.y;\r\n    }\r\n    // Is the new y pos plus crop height going to exceed the bottom bound\r\n    else if (accDy + cropSize.height > imageBounds.height + imageBounds.y) {\r\n      // Then set the y pos so the crop frame touches the bottom edge\r\n      let limitedYPos = imageBounds.y + imageBounds.height - cropSize.height;\r\n      accDy = limitedYPos;\r\n    } else {\r\n      // It's somewhere in between - no formatting required\r\n    }\r\n    // Record the accumulated pan and reset the pan refs to zero\r\n    panX.current.setValue(0);\r\n    panY.current.setValue(0);\r\n    setAccumluatedPan({ x: accDx, y: accDy });\r\n  };\r\n\r\n  const checkResizeBounds = ({\r\n    translationX,\r\n    translationY,\r\n  }:\r\n    | PanGestureHandlerGestureEvent[\"nativeEvent\"]\r\n    | { translationX: number; translationY: number }) => {\r\n    // Check we haven't gone out of bounds when resizing - allow it to be\r\n    // resized up to the appropriate bounds if so\r\n    const { width: maxWidth, height: maxHeight } = imageBounds;\r\n    const { width: minWidth, height: minHeight } = minimumCropDimensions;\r\n    const { x, y } = getTargetCropFrameBounds({ translationX, translationY });\r\n    const animatedWidth = cropSize.width + x;\r\n    const animatedHeight = cropSize.height + y;\r\n    let finalHeight = animatedHeight;\r\n    let finalWidth = animatedWidth;\r\n    // Ensure the width / height does not exceed the boundaries -\r\n    // resize to the max it can be if so\r\n    if (animatedHeight > maxHeight) {\r\n      finalHeight = maxHeight;\r\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\r\n    } else if (animatedHeight < minHeight) {\r\n      finalHeight = minHeight;\r\n      if (lockAspectRatio) finalWidth = finalHeight * fixedAspectRatio;\r\n    }\r\n    if (animatedWidth > maxWidth) {\r\n      finalWidth = maxWidth;\r\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\r\n    } else if (animatedWidth < minWidth) {\r\n      finalWidth = minWidth;\r\n      if (lockAspectRatio) finalHeight = finalWidth / fixedAspectRatio;\r\n    }\r\n    // Update the accumulated pan with the delta from the pan refs\r\n    setAccumluatedPan({\r\n      x: accumulatedPan.x + (isLeft ? -x : 0),\r\n      y: accumulatedPan.y + (isTop ? -y : 0),\r\n    });\r\n    // Zero out the pan refs\r\n    panX.current.setValue(0);\r\n    panY.current.setValue(0);\r\n    // Update the crop size to the size after resizing\r\n    setCropSize({\r\n      height: finalHeight,\r\n      width: finalWidth,\r\n    });\r\n  };\r\n\r\n  return (\r\n    <GestureHandlerRootView style={styles.container}>\r\n      <PanGestureHandler\r\n        onGestureEvent={onOverlayMove}\r\n        onHandlerStateChange={(e) => onHandlerStateChange(e)}\r\n      >\r\n        <Animated.View\r\n          style={[\r\n            styles.overlay,\r\n            animatedCropSize,\r\n            {\r\n              transform: [\r\n                { translateX: Animated.add(panX.current, accumulatedPan.x) },\r\n                { translateY: Animated.add(panY.current, accumulatedPan.y) },\r\n              ],\r\n            },\r\n          ]}\r\n        >\r\n          {\r\n            // For reendering out each section of the crop overlay frame\r\n            horizontalSections.map((hsection) => {\r\n              return (\r\n                <View style={styles.sectionRow} key={hsection}>\r\n                  {verticalSections.map((vsection) => {\r\n                    const key = hsection + vsection;\r\n                    return (\r\n                      <View style={[styles.defaultSection]} key={key}>\r\n                        {\r\n                          // Add the corner markers to the topleft,\r\n                          // topright, bottomleft and bottomright corners to indicate resizing\r\n                          key == \"topleft\" ||\r\n                          key == \"topright\" ||\r\n                          key == \"bottomleft\" ||\r\n                          key == \"bottomright\" ? (\r\n                            <View\r\n                              style={[\r\n                                styles.cornerMarker,\r\n                                hsection == \"top\"\r\n                                  ? { top: -4, borderTopWidth: 7 }\r\n                                  : { bottom: -4, borderBottomWidth: 7 },\r\n                                vsection == \"left\"\r\n                                  ? { left: -4, borderLeftWidth: 7 }\r\n                                  : { right: -4, borderRightWidth: 7 },\r\n                              ]}\r\n                            />\r\n                          ) : null\r\n                        }\r\n                      </View>\r\n                    );\r\n                  })}\r\n                </View>\r\n              );\r\n            })\r\n          }\r\n        </Animated.View>\r\n      </PanGestureHandler>\r\n    </GestureHandlerRootView>\r\n  );\r\n};\r\n\r\nexport { ImageCropOverlay };\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    height: \"100%\",\r\n    width: \"100%\",\r\n    position: \"absolute\",\r\n  },\r\n  overlay: {\r\n    height: 40,\r\n    width: 40,\r\n    backgroundColor: \"#33333355\",\r\n    borderColor: \"#ffffff88\",\r\n    borderWidth: 1,\r\n  },\r\n  sectionRow: {\r\n    flexDirection: \"row\",\r\n    flex: 1,\r\n  },\r\n  defaultSection: {\r\n    flex: 1,\r\n    borderWidth: 0.5,\r\n    borderColor: \"#ffffff88\",\r\n    justifyContent: \"center\",\r\n    alignItems: \"center\",\r\n  },\r\n  cornerMarker: {\r\n    position: \"absolute\",\r\n    borderColor: \"#ffffff\",\r\n    height: 30,\r\n    width: 30,\r\n  },\r\n});\r\n"]}